<?xml version="1.0" encoding="UTF-8"?>
<!--
  ~ This is part of Geomajas, a GIS framework, http://www.geomajas.org/.
  ~
  ~ Copyright 2008-2011 Geosparc nv, http://www.geosparc.com/, Belgium.
  ~
  ~ The program is available in open source according to the GNU Affero
  ~ General Public License. All contributions in this program are covered
  ~ by the Geomajas Contributors License Agreement. For full licensing
  ~ details, see LICENSE.txt in the project root.
  -->
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<chapter id="chapter-introduction">
  <title>Introduction</title>

  <para>The rasterizing plug-in enables the conversion of vector data
  (coordinate-based geometry definitions) to raster data (images). It allows
  to extend the vector layer rendering pipeline by introducing an extra
  rasterizing step. The vector tile response will thereby contain an URL
  content-type that allows the client to fetch the tile as a normal
  image.</para>

  <para>From a visualization view point, rasterizing tiles are quite
  comparable to vector tiles for many use cases such as panning and zooming.
  They have significant advantages when the amount of vector data is high,
  either in terms of features or in the amount of coordinates for each
  feature. Especially for web clients, DOM-based vector rendering (SVG/VML) is
  quite slow and should not be used beyond a couple of thousand features
  (state of the art as of beginning 2011). In this case rasterizing provides a
  significant performance boost, especially when combined with server-side
  caching of the image tiles.</para>

  <para>On the other hand, there are some use cases which are evidently
  difficult to treat without vectorial information at hand:</para>

  <para><itemizedlist>
      <listitem>
        <para>editing of geometries.</para>
      </listitem>

      <listitem>
        <para>snapping to other layers.</para>
      </listitem>

      <listitem>
        <para>selection of features.</para>
      </listitem>
    </itemizedlist>Geomajas provides the ability to load vector data on demand
  in such cases, thereby combining the best of both worlds.</para>

  <section>
    <title>Pipeline overview</title>

    <para>The rasterizing plug-in adds a rasterizing service and some pipeline
    steps to the framework, as well as a controller to serve the tile
    images.</para>

    <para>The normal pipeline for getting the vector tiles is enhanced with an
    extra rasterizing step which is indicated in green in the following
    figure:</para>

    <para><figure>
        <title>Vector tile pipeline for rasterizing</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/rastertilestep.png" width="100%" />
          </imageobject>
        </mediaobject>
      </figure>The rasterizing takes place in the RasterTile step, right after
    the point where all the features have been collected and transformed to
    the screen coordinate system. It goes in front of the GetTileFill step
    because it has to work with the complete set of interacting features of
    the tile. The GetTileFill step filters the features to assure they are
    only drawn in one of the tiles<footnote>
        <para>This is needed for SVG and VML rendering to avoid such features
        being drawn twice. Features are included in the tile which contains
        the first point of the geometry or (if the first point is not inside
        the layer maximum bounds) to the super-tile.</para>
      </footnote>. For rasterizing this is not necessary, as drawing cannot
    span the tile boundary.</para>

    <para>The RasterTile step performs the following actions:</para>

    <para><itemizedlist>
        <listitem>
          <para>check the rebuild cache and make sure it has the necessary
          context to rebuild the rasterized tile image.</para>
        </listitem>

        <listitem>
          <para>if the rasterizing needs to be done now:<itemizedlist>
              <listitem>
                <para>build the rasterized tile image by calling the
                ImageService (see next chapter).</para>
              </listitem>

              <listitem>
                <para>put the rasterized tile image in the normal cache so
                that it can be fetched by the controller.</para>
              </listitem>
            </itemizedlist></para>
        </listitem>

        <listitem>
          <para>set the feature content of the tile to a unique URL that
          contains the cache key.</para>
        </listitem>
      </itemizedlist>After this step, the cache must contain both the rebuild
    information and the rasterized image. The tile that is returned must
    contain the URL to fetch the tile image. Normally, the client will
    immediately fetch this URL from the server in a separate client-server
    interaction.</para>

    <para>Our next figure shows how this URL request is handled:<figure>
        <title>URL handling for rasterization</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/raster_url_handling.png" width="100%" />
          </imageobject>
        </mediaobject>
      </figure></para>

    <para>The following series of actions take place:<itemizedlist>
        <listitem>
          <para>the dispatcher servlet dispatches the request to the
          RasterizingController, based on the URL prefix
          <code>/rasterizing/.</code></para>
        </listitem>

        <listitem>
          <para>the RasterizingController invokes a separate rasterizing
          pipeline, which handles the following steps.</para>
        </listitem>

        <listitem>
          <para>The rasterizing cache is checked so if it contains the
          requested image. If successful, the pipeline ends.</para>
        </listitem>

        <listitem>
          <para>the Rasterize step tries to fetch the rebuild context from the
          rebuild cache. If successful, the vector tile pipeline is invoked
          again and the resulting image is returned. If not, an empty image is
          returned.</para>
        </listitem>
      </itemizedlist></para>

    <para>Note that you can configure when the initial rasterizing takes
    place. This can either be done when requesting the vector tile or when
    requesting the tile image. There is a trade of, handling the rasterizing
    at vector tile requests is most increases throughput for the back-end, but
    seems slower for the client.</para>
  </section>

  <section>
    <title>The image and rendering services</title>

    <para>The rasterizing process has an application-level service, called
    <code>ImageService</code> ,which has methods for creating a legend and map
    image. This service internally calls a pipeline with three steps. The most
    important step, and the step which is responsible for the actual
    rendering, is the <code>RenderMapStep</code>, This step uses itself a
    <code>RenderingService</code>, which is primarily a wrapper of the
    GeoTools <code>StreamRenderer</code> class.</para>

    <para>Our rasterizing is based on the GeoTools rasterizing approach. In
    this approach, a map context is constructed that contains all the
    necessary information to rasterize a map. A map context contains the
    following components:</para>

    <itemizedlist>
      <listitem>
        <para>A list of layers: layers can be ordinary vector layers, raster
        layers or so-called direct layers, which are responsible for their own
        rendering.</para>
      </listitem>

      <listitem>
        <para>A view port: a view port contains an area of interest and a
        screen area. It provides the transformation between map an screen
        coordinates.</para>
      </listitem>
    </itemizedlist>

    <para>The actual rasterizing happens by passing the map context to the
    <code>RenderingService</code> along with a <code>Graphics2D</code> object
    for drawing (usually to an internal buffer).</para>

    <para>The following picture shows the services and the interaction with
    pipeline steps and factories:</para>

    <figure>
      <title>Image service</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/imageservice.png" width="50%" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>The image service can be used to rasterize single tiles or complete
    maps, depending on the composition of the map context. The
    <code>ImageService</code> does not directly take a map context as an
    argument, but expects a <code>ClientMapInfo</code> DTO object
    instead:</para>

    <programlisting>public interface ImageService {

    void writeMap(OutputStream stream, ClientMapInfo clientMapInfo) throws GeomajasException;

    void writeLegend(OutputStream stream, ClientMapInfo clientMapInfo) throws GeomajasException;

}</programlisting>

    <para>The <code>ClientMapInfo</code> DTO object has been extended a bit to
    include all the rasterizing information needed.</para>
  </section>
</chapter>
