<?xml version="1.0" encoding="UTF-8"?>
<!--
  ~ This is part of Geomajas, a GIS framework, http://www.geomajas.org/.
  ~
  ~ Copyright 2008-2013 Geosparc nv, http://www.geosparc.com/, Belgium.
  ~
  ~ The program is available in open source according to the GNU Affero
  ~ General Public License. All contributions in this program are covered
  ~ by the Geomajas Contributors License Agreement. For full licensing
  ~ details, see LICENSE.txt in the project root.
  -->
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<chapter id="ch-arch">
  <title>PureGWT face architecture</title>

  <para>This part of the documentation describes the main architecture and API
  of the PureGWT face for Geomajas. For actual code examples or more detail on
  how to use them, visit the "HowTo" guide.</para>

  <section>
    <title>The central Map API</title>

    <para>This section describes the interfaces of the most crucial object
    definitions within the API: those that make up the central map model.
    Central in all this, is the <code>MapPresenter</code>. This is the
    interface that represents a map in Geomajas. This
    <code>MapPresenter</code> in turn provides 2 very important interfaces
    through getters: the <code>ViewPort</code> and the
    <code>LayersModel</code>.</para>

    <para>Quickly speaking, the <code>ViewPort</code> provides methods and
    events for changes in the viewing area of the map. In other words, it
    determines the map's navigation. The <code>LayersModel</code> on the other
    hand is what it's name implies: a model that governs a set of
    layers.</para>

    <section>
      <title>MapPresenter</title>

      <para>The MapPresenter represents the central map interface and as such
      it determines the map's functionalities. It provides support for many of
      the topics that are discussed in the following sections, such as
      MapControllers or an EventBus.</para>
    </section>

    <section>
      <title>ViewPort</title>

      <para>The <code>ViewPort</code> can be seen of as the navigator behind
      the map. It manages the map's navigation (by making it zoom or pan) and
      sends the required events. On top of that, the <code>ViewPort</code>
      also has a second responsibility in providing transformations between
      "WorldSpace" and "ViewSpace" (visit the <link
      linkend="world_vs_screen">WorldSpace vs ScreenSpace</link> section for
      more information).</para>
    </section>

    <section>
      <title>LayersModel</title>

      <para>Also part of the central map model, is a separate interface for
      managing all the layers of the map. As is typically the case in GIS,
      people work not just with one type of data, but with many different
      types that are all represented by "layers" in a map. These layers always
      have a certain order in which they are drawn, as they lie on top of each
      other.</para>

      <para>This model provides methods to add and remove layers, to change
      layer order, to retrieve layer information etc. Most changes in the
      layer model will trigger some event that can always be captured.</para>
    </section>

    <section>
      <title>Layers</title>

      <para>As many different types of layers exist all with their own
      specific set of functionalities, we have decided to reflect this
      diversity in the layer interface, by splitting it up in multiple
      'functional' interfaces. There is still a main Layer interface, which
      must always be implemented, but layer implementation can decide for
      themselves which of the 'functional' interfaces they support and which
      they don't.</para>

      <para></para>
    </section>
  </section>

  <section>
    <title>Events</title>

    <para>Associated with the functionalities in the central map interfaces,
    are several events that signal changes in the model to all registered
    handlers. Note that the term <code>Handler</code> is used, not listener,
    as we try to follow the GWT naming conventions. As of GWT 2.x, the use of
    a central <code>EventBus</code> has been promoted to work together with an
    MVP approach. The PureGWT face has incorporated this train of thought, and
    provides a map-centric <code>EventBus</code>. In other words, every
    <code>MapPresenter</code> governs it's own <code>EventBus</code>.</para>

    <para>This means that for <code>Handlers</code> that are registered on
    such an <code>EventBus</code>, only events that have originated within
    that map will reach it. Here is an example of how one can attach a Handler
    to an EventBus:</para>

    <programlisting>mapPresenter.getEventBus().addHandler(MapResizedEvent.TYPE, new MapResizedHandler() {

    public void onMapResized(MapResizedEvent event) {
        // The map has resized. Quick, do something meaningful!
    }
});</programlisting>

    <para>In the example above a <code>MapResizedHandler</code> was used that
    listens to <code>MapResizedEvents</code>. From the moment the
    <code>MapResizedHandler</code> has been registered, it will receive all
    events that indicate the map has been resized.</para>

    <para>Time to go over all supported events and explain their purpose. Note
    that every event in this list is part of the PureGWT API within Geomajas.
    All event and handler classes can be found in the following package:
    <code>org.geomajas.puregwt.client.map.event</code>.</para>

    <para><emphasis role="bold">Map events:</emphasis></para>

    <table>
      <title>Map Events</title>

      <tgroup cols="3">
        <thead>
          <row>
            <entry align="center">Event</entry>

            <entry align="center">Handler</entry>

            <entry align="center">Description</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry>MapInitializationEvent</entry>

            <entry>MapInitializationHandler</entry>

            <entry>Event that is fired when the map has been initialized. Only
            after this point will layers be available.</entry>
          </row>

          <row>
            <entry>MapResizedEvent</entry>

            <entry>MapResizedHandler</entry>

            <entry>Event that is fired when the map widget has changed
            size.</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para><emphasis role="bold">ViewPort events:</emphasis><table>
        <title>ViewPort Events</title>

        <tgroup cols="3">
          <thead>
            <row>
              <entry align="center">Event</entry>

              <entry align="center">Handler</entry>

              <entry align="center">Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>ViewPortChangedEvent</entry>

              <entry>ViewPortChangedHandler</entry>

              <entry>Event that is fired when the map both zooms and pans at
              the same time.</entry>
            </row>

            <row>
              <entry>ViewPortDraggedEvent</entry>

              <entry>ViewPortChangedHandler</entry>

              <entry>Event that is fired when the map is being panned.</entry>
            </row>

            <row>
              <entry>ViewPortScaledEvent</entry>

              <entry>ViewPortChangedHandler</entry>

              <entry>Event that is fired when the map zooms is or out keeping
              the same center.</entry>
            </row>

            <row>
              <entry>ViewPortTranslatedEvent</entry>

              <entry>ViewPortChangedHandler</entry>

              <entry>Event that is fired when the map is being
              translated.</entry>
            </row>
          </tbody>
        </tgroup>
      </table></para>

    <para><emphasis role="bold">Layer events:</emphasis><table>
        <title>Layer Events</title>

        <tgroup cols="3">
          <thead>
            <row>
              <entry align="center">Event</entry>

              <entry align="center">Handler</entry>

              <entry align="center">Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>LayerAddedEvent</entry>

              <entry>MapCompositionHandler</entry>

              <entry>Event that is fired when a new layer has been added to
              the map.</entry>
            </row>

            <row>
              <entry>LayerRemovedEvent</entry>

              <entry>MapCompositionHandler</entry>

              <entry>Event that is fired when a layer has been removed from
              the map.</entry>
            </row>

            <row>
              <entry>LayerSelectedEvent</entry>

              <entry>LayerSelectionHandler</entry>

              <entry>Event that is fired when a layer is selected. Only one
              layer can be selected at any time, so these events often go
              together with layer deselect events.</entry>
            </row>

            <row>
              <entry>LayerDeselectedEvent</entry>

              <entry>LayerSelectionHandler</entry>

              <entry>Event that is fired when a layer has been
              deselected.</entry>
            </row>

            <row>
              <entry>LayerHideEvent</entry>

              <entry>LayerVisibilityHandler</entry>

              <entry>Event that is fired when a layer becomes
              invisible.</entry>
            </row>

            <row>
              <entry>LayerShowEvent</entry>

              <entry>LayerVisibilityHandler</entry>

              <entry>Event that is fired when a layer becomes visible.</entry>
            </row>

            <row>
              <entry>LayerLabelHideEvent</entry>

              <entry>LayerLabeledHandler</entry>

              <entry>Event that is fired when the labels for a layer have been
              turned off.</entry>
            </row>

            <row>
              <entry>LayerLabelShowEvent</entry>

              <entry>LayerLabeledHandler</entry>

              <entry>Event that is fired when the labels for a layer have been
              turned on.</entry>
            </row>

            <row>
              <entry>LayerOrderChangedEvent</entry>

              <entry>LayerOrderChangedHandler</entry>

              <entry>Event that is fired when the layer order has
              changed.</entry>
            </row>

            <row>
              <entry>LayerStyleChangedEvent</entry>

              <entry>LayerStyleChangedHandler</entry>

              <entry>Event that is fired when a layer has a new style.</entry>
            </row>
          </tbody>
        </tgroup>
      </table></para>

    <para><emphasis role="bold">Feature events:</emphasis><table>
        <title>Feature Events</title>

        <tgroup cols="3">
          <thead>
            <row>
              <entry align="center">Event</entry>

              <entry align="center">Handler</entry>

              <entry align="center">Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>FeatureSelectedEvent</entry>

              <entry>FeatureSelectionHandler</entry>

              <entry>Event that is fired when a feature has been
              selected.</entry>
            </row>

            <row>
              <entry>FeatureDeselectedEvent</entry>

              <entry>FeatureSelectionHandler</entry>

              <entry>Event that is fired when a selected feature has been
              deselected again.</entry>
            </row>
          </tbody>
        </tgroup>
      </table></para>
  </section>

  <section>
    <title id="graphics_rendering">Graphics &amp; Rendering</title>

    <para>This section will handle all rendering related topics, explaining
    the different render spaces (WorldSpace versus ScreenSpace), and how to
    make full advantage of them when trying to render objects on the map.
    Finally, the MapGadget will be introduced, which is an experimental
    interface for defining functional gadgets at a fixed location on the
    map.</para>

    <section>
      <title id="world_vs_screen">WorldSpace vs ScreenSpace</title>

      <para>Before trying to render anything on a map, it is crucial you
      understand the difference between WorldSpace and ScreenSpace. Both
      represent render spaces wherein the user can render his objects.</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>WorldSpace</emphasis>: World space describes a
          rendering space where all objects are expressed in the coordinate
          reference system of the map they are drawn in. As a result, all
          objects within world space move about with the view on the
          map.</para>

          <para>Let's say for example that a rectangle is rendered on a map
          with CRS lon-lat. The rectangle has origin (118,34) and width and
          height both equal to 1. Than this rectangle will cover the city of
          Los Angeles.</para>
        </listitem>

        <listitem>
          <para><emphasis>ScreenSpace</emphasis>: Screen space describes a
          rendering space where all objects are expressed in pixels with the
          origin in the top left corner of the map. Objects rendered in screen
          will always occupy a fixed position on the map. They are immobile
          and are not affected by changes in the map view.</para>
        </listitem>
      </itemizedlist>

      <caution>
        <para>Beware that drawing a great many objects in WorldSpace can slow
        down an application, as their positions need to be recalculated every
        time the map navgates.</para>
      </caution>
    </section>

    <section>
      <title>VectorObjectContainers &amp; VectorObjects</title>

      <para>For vector object rendering, the PureGWT face makes use of the
      Vaadin GwtGraphics library. This library provides all the necessary
      methods for standard SVG and VML rendering. The main interfaces to note
      are the <code>VectorObjectContainer</code> and the
      <code>VectorObject</code>.</para>

      <para>The VectorObjectContainer is a container object as the name
      implies and provides methods for storing and managing VectorObjects.
      These VectorObjects in turn are the individual objects (such as
      Rectangle, Circle, Path, ...) that can be drawn on the map.</para>

      <para>The PureGWT face has extended the VectorObjectContainer to provide
      a ScreenContainer and a WorldContainer. As you might have guessed, the
      ScreenContainer allows you to render objects in ScreenSpace while the
      WorldContainer allows you to render objects in WorldSpace.</para>

      <para>In order to acquire a ScreenContainer or WorldContainer, all one
      has to do is request such a container with the MapPresenter. This can be
      done by calling one of the following lines:</para>

      <programlisting>// Getting a WorldContainer:
WorldContainer worldContainer = mapPresenter.getWorldContainer("myWorld");

// Getting a ScreenContainer:
ScreenContainer screenContainer = mapPresenter.getScreenContainer("myScreen");</programlisting>

      <para>When acquiring such a container, you have to specify a name (see
      above 'myWorld' or 'myScreen'). If a container with such a name does not
      yet exist a new container is created and returned.</para>

      <remark>TODO: How about removing these containers again? Also add
      architectural images here.</remark>
    </section>

    <section>
      <title>MapGadgets</title>

      <para>The MapGadget is a standalone functional gadget that can be placed
      at a fixed position on the map. Examples are the navigation buttons and
      the scalebar. MapGadgets are notified of map navigation events, because
      they often require updating on those events.</para>

      <para>The position of a MapGadget is maintained by the face, but you
      have to make sure that the container has a "position: absolute"
      style.</para>
    </section>
  </section>

  <section>
    <title>Geometry manipulation</title>

    <para>The spatial package
    (<code>org.geomajas.puregwt.client.spatial</code>) contains a collection
    of math and geometry related classes and utilities to provide all the
    client-side calculations one should need. If really complex calculations
    need to be performed, it's best to let the server handle it anyway.</para>

    <para>Next to the expected Geometry definitions (Point, LineString,
    Polygon, ...) this package also provides a few mathematical concepts such
    as a Vector, Matrix or LineSegment.</para>

    <section>
      <title>Geometry definitions</title>

      <para>The geometry definitions on the client have been written to
      resemble the JTS (Java Topology Suite) geometry definitions. This
      definition in turn has been based upon the OGC Simple Feture
      Specification. You will find the same classes with each roughly the same
      methods. The main difference (beside the package name) is that the
      methods for complex geometry manipulation are left out.</para>

      <para>Supported geometries are:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Point</emphasis>: a geometry representation of a
          single coordinate.</para>
        </listitem>

        <listitem>
          <para><emphasis>MultiPoint</emphasis>: a geometry containing
          multiple Point geometries.</para>
        </listitem>

        <listitem>
          <para><emphasis>LineString</emphasis>: a list of connected
          coordinates. Sometimes also called a polyline.</para>
        </listitem>

        <listitem>
          <para><emphasis>LinearRing</emphasis>: an extension of the
          LineString geometry that expects the last coordinate to be equal to
          the first coordinate. In other words, a LinearRing is a closed
          LineString.</para>
        </listitem>

        <listitem>
          <para><emphasis>MultiLineString</emphasis>: a geometry containing
          multiple LineString geometries.</para>
        </listitem>

        <listitem>
          <para><emphasis>Polygon</emphasis>: a Polygon is a two-part
          geometry, consisting of an exterior LinearRing and a list of
          interior LinearRings. The exterior LinearRing, also called the
          shell, is the outer hull of the geometry, while the interior rings
          can be seen as holes in the exterior ring's surface area.</para>
        </listitem>

        <listitem>
          <para><emphasis>MultiPolygon</emphasis>: a geometry containing
          multiple Polygon geometries.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Spatial services</title>

      <para></para>
    </section>
  </section>

  <section>
    <title>User Interaction on the Map</title>

    <para>This section will handle the basics of interacting with the map, by
    listening and responding to the mouse events that are generated from the
    map. Instead of dealing with those mouse events directly, 2 interfaces
    have been created to shield you from having to attach the correct handlers
    to the correct DOM elements in the HTML tree.</para>

    <note>
      <para>If you want fine tuned control and attach custom mouse event
      handlers to custom objects on the map, have a look at the <link
      linkend="graphics_rendering">Graphics &amp; Rendering</link>
      section.</para>

      <para>This section here handles the interface that help shield you from
      such fine tuned but cumbersome mouse event handling.</para>
    </note>

    <para>The next 2 sections will cover the following 2 basic interfaces: the
    MapController and the MapListener.</para>

    <section>
      <title>MapController</title>

      <para>The MapController is an interface which listens to all mouse
      events that comes from the map (mouse up, mouse down, mouse move, ...)
      and has the possibility to react directly onto receiving such events.
      The MapController basically has all the freedom in the world to
      manipulate and manage the state of the map as events are being
      received.</para>

      <para>For example, it could prevent the default mouse event behaviour or
      even prevent event bubbling. But because the MapController has such
      freedom only one can be active at a time.</para>

      <para>An example of a MapController is the NavigationController which
      allows the user to navigate all around the map.</para>

      <para></para>
    </section>

    <section>
      <title>MapListener</title>

      <para>The other way of interacting with the map, is through
      MapListeners. A MapListener resembles a MapController quite a lot,
      except that it does not receive the real mouse events, but imitations of
      it. It therefore can not interfere with the normal browser event flow,
      but takes on a more passive form.</para>

      <para>As a result, multiple MapListeners can be active on a map at any
      one time. The MapListener is would therefore be the perfect tool for
      reporting or reacting without interfering, while a MapController is all
      about the interference.</para>
    </section>
  </section>

  <section>
    <title>Client/Server communication</title>

    <para></para>
  </section>
</chapter>
